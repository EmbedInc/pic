;   ***************************************************************
;   * Copyright (C) 2011, Embed Inc (http://www.embedinc.com)     *
;   *                                                             *
;   * Permission to copy this file is granted as long as this     *
;   * copyright notice is included in its entirety at the         *
;   * beginning of the file, whether the file is copied in whole  *
;   * or in part and regardless of whether other information is   *
;   * added to the copy.                                          *
;   *                                                             *
;   * The contents of this file may be used in any way,           *
;   * commercial or otherwise.  This file is provided "as is",    *
;   * and Embed Inc makes no claims of suitability for a          *
;   * particular purpose nor assumes any liability resulting from *
;   * its use.                                                    *
;   ***************************************************************
;
;   USB stream command processor.  The routines in this module interpret and
;   process the command stream coming from the host computer via the USB.
;
;   The code in this module requires some global flags in addition to the
;   standard USB flags.  The flags below are defined such that they can be
;   copied into the project include file and uncommented.
;
;   /flag    cmdreset            ;reset command processor logic next time run
;   /flag    namecmd             ;name get routines acquired by command processor
;   /flag    rsp_lock            ;response to host is locked by a task
;   /flag    cmd_rsplock         ;response lock is being held by command proc task
;
;   The CMDRESET flag is not needed if USE_USBRESET set to TRUE below.  The USB
;   code automatically sets USBRESET when a USB reset is detected.  This is the
;   only app interface for getting notified about a USB reset.  The application
;   may need to do other things than just resetting the command processor on a
;   USB reset.  In that case, USBRESET should be a condition handled in the main
;   event loop, which then sets CMDRESET as one of its tasks.  If the only
;   response to a USB reset is to reset the command processor, then the USBRESET
;   flag can be used here directly.  That is done by setting USE_USBRESET to
;   TRUE.
;
/include "qq2.ins.aspic"

         extern  currtask    ;0-N number of the currently running task
         extern_flags        ;declare global flag bits EXTERN

;*******************************************************************************
;
;   Configuration settings.
;
/const   use_usbreset bool = False ;use USBRESET flag directly, CMDRESET not used
stacksz  equ     64          ;size of command processor data stack
lbank    equ     0           ;register bank for the local state of this module
;
;   Derived constants.
;
lbankadr equ     bankadr(lbank) ;address within local state register bank

;*******************************************************************************
;
;   Global state.  All this state is assumed to be in the GBANK register
;   bank by other modules.
;
         defram  gbankadr

;*******************************************************************************
;
;   Local state.
;
         defram  lbankadr

cmdtask  res     1           ;ID of the command processing task
;
;   The command processor stack goes in its own data section so that the linker
;   has more freedom in placing it.
;
.cmdstack udata
cmdstack res     stacksz     ;command processing task data stack


.cmd     code

;*******************************************************************************
;
;   Subroutine CMD_INIT
;
;   Initialize the hardware and software state managed by this module.
;
         glbsub  cmd_init, noregs

         dbankif lbankadr
         setf    cmdtask     ;init to command processing task is not running

         leaverest

;*******************************************************************************
;
;   Subroutine CMD_YIELD
;
;   Special task yield routine for the command processing task only.  This
;   routine may only be called by command processing code run from the command
;   processor.
;
;   Let other tasks run for a time slice.  In addition, this routine restarts
;   the command processing logic if a USB reset was received.  That means the
;   previous command stream was aborted and a new one has been started.
;
;   Since this routine calls TASK_YIELD, all registers not listed in TSKSAVE are
;   trashed.
;
         glbsub  cmd_yield

         gcall   task_yield  ;give other tasks a chance to run

/if use_usbreset
  /then
         skip_nflag usbreset
  /else
         skip_nflag cmdreset
  /endif
         jump    task_restart ;USB was reset, reset the command processor

         leaverest

;*******************************************************************************
;
;   Subroutine CMD_GET8
;
;   Get the next input byte into REG0.  This subroutine will not return until an
;   input byte is available.  Only the registers listed in TSKSAVE will be
;   preserved.  Other tasks will be run while waiting for a new input byte to
;   become available.  No yield is performed if a byte is immediately available.
;
         glbsub  cmd_get8, regf1

get8_byte unbank             ;back here until input byte is available
         clrf    reg1        ;indicate to transfer byte if one is available
         gcall   usb_get1    ;try to get a byte from the USB
         btfss   reg1, usbs_noxf ;didn't get a byte ?
         jump    get8_leave  ;got a byte, all done
         ;
         ;   No byte was received.  Let all other tasks run, then try again.
         ;
         popregs savedregs
         mcall   cmd_yield   ;give other tasks a chance to run
         pushregs savedregs
         jump    get8_byte   ;back to try getting a byte again

get8_leave unbank            ;returning with received byte in REG0
         leaverest

;*******************************************************************************
;
;   Subroutine CMD_GET16
;
;   Get the next 2 input bytes as a 16 bit value into REG1:REG0.  The input
;   bytes are assumed to be in high to low byte order.
;
         glbsub  cmd_get16

         mcall   cmd_get8    ;get the high byte into REG1
         movff   reg0, reg1
         mcall   cmd_get8    ;get the low byte into REG0

         leaverest

;*******************************************************************************
;
;   Subroutine CMD_GET24
;
;   Get the next 3 input bytes as a 24 bit value into REG2:REG1:REG0.  The input
;   bytes are assumed to be in high to low byte order.
;
         glbsub  cmd_get24

         mcall   cmd_get8    ;get byte 2 into REG2
         movff   reg0, reg2
         mcall   cmd_get8    ;get byte 1 into REG1
         movff   reg0, reg1
         mcall   cmd_get8    ;get byte 0 into REG0

         leaverest

;*******************************************************************************
;
;   Subroutine CMD_GET32
;
;   Get the next 4 input bytes as a 32 bit value into REG:3REG2:REG1:REG0.  The
;   input bytes are assumed to be in high to low byte order.
;
         glbsub  cmd_get32

         mcall   cmd_get8    ;get byte 3 into REG3
         movff   reg0, reg3
         mcall   cmd_get8    ;get byte 2 into REG2
         movff   reg0, reg2
         mcall   cmd_get8    ;get byte 1 into REG1
         movff   reg0, reg1
         mcall   cmd_get8    ;get byte 0 into REG0

         leaverest

;*******************************************************************************
;
;   Subroutine CMD_LOCK_OUT
;
;   Acquire exclusive access to sending to the host.  The lock must be held
;   while sending a response to guarantee the bytes from responses from multiple
;   tasks do not get interleaved.
;
         glbsub  cmd_lock_out

lck_loop unbank
         dbankif gbankadr
         skip_flag rsp_lock  ;already locked ?
         jump    lck_avail   ;no, the lock is available
         gcall   task_yield_save ;let all other tasks run for a bit
         jump    lck_loop    ;back and check lock again

lck_avail dbankis gbankadr   ;the lock is available
         bsf     flag_rsp_lock ;grab the lock

         dbankif lbankadr
         movf    cmdtask, w  ;get the ID of the command processing task
         dbankif gbankadr
         xorwf   currtask, w ;compare to ID of the current task
         skip_nz             ;this is not command processor ?
         bsf     flag_cmd_rsplock ;indicate command processor has the response lock

         leaverest

;*******************************************************************************
;
;   Subroutine CMD_UNLOCK_OUT
;
;   Release the exclusive lock on sending to the host.
;
         glbsub  cmd_unlock_out

         dbankif gbankadr
         bcf     flag_rsp_lock ;response stream is not locked
         bcf     flag_cmd_rsplock ;command processing task doesn't have the lock

         leaverest

;*******************************************************************************
;
;   Subroutine CMD_PUT8
;
;   Send the byte in REG0 as a response byte to the host.  Registers not listed
;   in MSKSAVE may be trashed.
;
         glbsub  cmd_put8, regf1

put8_byte unbank             ;back here to retry sending byte
         clrf    reg1        ;indicate to tranfer byte if possible
         gcall   usb_put1    ;try to send the byte
         btfss   reg1, usbs_noxf ;the byte was not sent ?
         jump    put8_leave  ;the byte was sent
         ;
         ;   No byte was sent.  Let all other tasks run, then try again.
         ;
         popregs savedregs
         mcall   cmd_yield   ;give other tasks a chance to run
         pushregs savedregs
         jump    put8_byte

put8_leave unbank            ;common exit point
         leaverest

;*******************************************************************************
;
;   Subroutine CMD_PUT16
;
;   Send the 16 bits in REG1:REG0 out the response stream.  The bytes are sent
;   in most to least significant order.
;
         glbsub  cmd_put16

         pushreg reg0        ;temp save byte 0 on the stack

         movff   reg1, reg0
         mcall   cmd_put8    ;send byte 1

         popreg  reg0        ;get byte 0 back into REG0
         mcall   cmd_put8    ;send byte 0
         leaverest

;*******************************************************************************
;
;   Subroutine CMD_PUT24
;
;   Send the 24 bits in REG2:REG1:REG0 out the response stream.  The bytes are
;   sent in most to least significant order.
;
         glbsub  cmd_put24

         pushreg reg0        ;temp save byte 0 on the stack

         movff   reg2, reg0
         mcall   cmd_put8    ;send byte 2
         movff   reg1, reg0
         mcall   cmd_put8    ;send byte 1

         popreg  reg0        ;get byte 0 back into REG0
         mcall   cmd_put8    ;send byte 0
         leaverest

;*******************************************************************************
;
;   Subroutine CMD_PUT32
;
;   Send the 32 bits in REG3:REG2:REG1:REG0 out the response stream.  The bytes
;   are sent in most to least significant order.
;
         glbsub  cmd_put32

         pushreg reg0        ;temp save byte 0 on the stack

         movff   reg3, reg0
         mcall   cmd_put8    ;send byte 3
         movff   reg2, reg0
         mcall   cmd_put8    ;send byte 2
         movff   reg1, reg0
         mcall   cmd_put8    ;send byte 1

         popreg  reg0        ;get byte 0 back into REG0
         mcall   cmd_put8    ;send byte 0
         leaverest

;*******************************************************************************
;
;   Subroutine CMD_START
;
;   Start up host command processing.  This routine launches a new task to
;   perform the host command processing, then returns.
;
         glbsub  cmd_start, regf0 | regf1 | regf2 | regf3

         task_create cmd_task, cmdstack ;start the host command processing task

         leaverest

;*******************************************************************************
;
;   Command task.
;
cmd_task unbank              ;task start point
         movff   currtask, cmdtask ;save ID of the command processing task
;
;   Command processor restart point.  This entry point can be called or jumped
;   to in any state, including with the call and data stacks not empty.
;
task_restart unbank          ;will restart here on a USB reset
         dbankif stkptr
         clrf    stkptr      ;reset the call stack to empty
         stack_set cmdstack  ;reset the data stack to empty
         dbankif gbankadr
/if use_usbreset
  /then
         clrflag usbreset    ;clear any pending reset
  /else
         clrflag cmdreset    ;clear any pending reset
  /endif
;
;   Initialize command processing state for after a USB reset.
;
         ;
         ;   Release the NAME_GET_xxx routines if locked by this task.
         ;
         dbankif gbankadr
         btfss   flag_namecmd ;this task has NAME_GET locked ?
         jump    no_namelock ;no
         bcf     flag_namecmd ;indicate no longer locked
         gcall   name_get_end ;release the lock
no_namelock unbank
;
;   Wait for the USB to be usable before attempting to do USB I/O.
;
cmd_waitusb unbank
         mcall   cmd_yield   ;give other tasks a chance to run
         dbankif gbankadr
         btfss   flag_usbon  ;USB is ready for app use ?
         jump    cmd_waitusb ;no, go back and check again
;
;   Command routines jump here when done.
;
cmd_done unbank              ;done successfully processing last command
         dbankif stkptr
         clrf    stkptr      ;reset the call stack to empty
         stack_set cmdstack  ;reset the data stack to empty
         ;
         ;   Release the lock on the response stream to the host if it is held
         ;   by this task.
         ;
         dbankif gbankadr
         btfss   flag_cmd_rsplock ;response stream locked by this task ?
         jump    no_rsplock  ;no
         mcall   cmd_unlock_out ;release lock on the response stream
no_rsplock unbank
;
;   Process next command.
;
         ;
         ;   Seed the address of CMD_DONE onto the call stack.  This allows
         ;   command routines to be subroutines with a return from the top level
         ;   ending the command by going to CMD_DONE.
         ;
         dbankif stkptr
         incf    stkptr      ;claim one stack location
         dbankif tosl
         movlw   low cmd_done
         movwf   tosl        ;set low byte of return address
         dbankif tosh
         movlw   high cmd_done
         movwf   tosh        ;set high byte of return address
         dbankif tosu
         movlw   upper cmd_done
         movwf   tosu        ;set upper byte of return address

cmd_next unbank              ;back here to interpret next byte as command opcode
         gcall   task_yield  ;give other tasks a chance to run
         mcall   cmd_get8    ;get command opcode byte into REG0
         dispatch cmd_table  ;jump to the selected command routine
         jump    cmd_next    ;not a valid opcode, back to get next

;*******************************************************************************
;
;   Macro SENDK const
;
;   Send the indicated 8 bit constant value to the host.
;
;   W, REG0, and the current bank setting are trashed.  All registers not listed
;   in MSKSAVE may be trashed.
;
sendk    macro   const
         loadk8  reg0, const
         mcall   cmd_put8
         endm

;*******************************************************************************
;
;   Command PING
;
;   Send the PONG response.
;
cm_ping  unbank
         mcall   cmd_lock_out
         sendk   rsp_pong
         return

;*******************************************************************************
;
;   Command FWINFO
;
;   Send FWINFO response, which indicates the firmware version.
;
cm_fwinfo unbank
         mcall   cmd_lock_out

         sendk   rsp_fwinfo  ;send FWINFO response opcode
         sendk   fwtype      ;type ID for this firmware
         sendk   fwver       ;1-255 firmware version number
         sendk   fwseq       ;1-255 firmware sequence number

         return

;*******************************************************************************
;
;   Command NAMESET n string
;
;   Sets the new non-volatile name of this unit.  Exactly N name characters
;   follow N.
;
cm_nameset unbank
         mcall   cmd_get8    ;get N
         movf    reg0, w
         bz      nameset_leave ;no name string bytes to get ?
         movwf   reg1        ;init number of name string bytes left to get

nameset_byte unbank
         mcall   cmd_get8    ;get and ignore this name string byte
         decfsz  reg1        ;count one less name byte left to get
         jump    nameset_byte ;back to get the next name byte

nameset_leave unbank
         jump    cmd_done    ;done processing this command

;*******************************************************************************
;
;   Command NAMEGET
;
;   Send NAME response to indicate the user-settable unit name.
;
cm_nameget unbank
         gcall   name_get_start ;set up for getting name, length into REG0
         dbankif gbankadr
         bsf     flag_namecmd ;indicate we have the NAME_GET lock
         movff   reg0, reg1  ;save number of name characters

         mcall   cmd_lock_out ;acquire lock on the response stream
         sendk   rsp_name    ;send response opcode
         movff   reg1, reg0
         mcall   cmd_put8    ;send the number of name characters to follow
name_loop unbank             ;back here to send each new name character
         movf    reg1
         bz      name_done   ;done sending all the name characters ?
         gcall   name_get_char ;get this name character
         mcall   cmd_put8    ;send it
         decf    reg1        ;count one less character left to do
         jump    name_loop   ;back to send next name char
name_done unbank             ;done sending all the name characters
         mcall   cmd_unlock_out ;release lock on response stream to host

         gcall   name_get_end ;done getting unit name
         dbankif gbankadr
         bcf     flag_namecmd ;indicate we are not holding the NAME_GET lock
         return

;*******************************************************************************
;
;   Commands dispatch table.
;
.cmdtable code_pack
         dsp_start cmd_table ;start command opcodes dispatch table

         dsp_entry 0, cmd_done ;NOP
         dsp_entry 1, cm_ping ;PING, send PONG response
         dsp_entry 2, cm_fwinfo ;send firmware information
         dsp_entry 3, cm_nameset ;set unique name (accepted but ignored)
         dsp_entry 4, cm_nameget ;send unique name of this unit

         dsp_end cmd_table   ;end of command opcodes dispatch table

         end
